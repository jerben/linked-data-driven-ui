\section{Background}\label{background}

This section discusses the problems with the process of developing UIs today. It also provides the theoretical backgroung by highlighting the main building blocks of the UI framework.

\subsection{Evolution of UI web development}\label{history}

In the early days of the Internet, websites were mostly \textbf{static files} accessible under certain URLs. Those files were often created manually or generated by using WYSIWYG editors. The served files were mostly styles (CSS), static assets and markup that the browsers had to render.

\textbf{Dynamically generated} content became popular with the rise of PHP. Websites were now able to show different things to each user based on previous interactions. The files that were served to the browsers were still the same static files. The markup was not hard coded anymore but dynamically rendered on the server upon user request.
\\ Developers had to work with templating languages to implement UIs that received that usually from the same server.

Websites became \textbf{truly interactive} with the introduction of AJAX. AJAX allowed the browser to asynchronously communicate with the server while the user was interacting with the website. Google was able to give search suggestions in real-time while the user was typing the search term. Websites were still rendered on the server but the served files additionally contained JavaScript that was run by the browser.
\\ UI development involved working with templating languages, styling and a small amount of programming.

The amount of interactive elements on websites and their \textbf{complexity increased}. What was once a text input field with real-time suggestions is now a full-text search interface with complex filtering and sorting options. The standardization of browser APIs was in the early stages and developers had to spend effort to create a consistent user experience across various browsers.
\\ Tools like jQuery emerged that provided a single interface for multiple browsers. The websites were still dynamically rendered on the server and just enriched in the browser by running JavaScript.

The first applications appeared providing a user experience in the browser similar to the one of fat desktop applications. The files that the server sent to the browser were mostly JavaScript. The browser ran that JavaScript application to render the website and to react on user input. It communicated with the server using AJAX and the website was not rendered on the server anymore. Instead a single website was served on which the whole application lifecycle took place. \textbf{Single page applications} (SPA) were born.
\par Development of UIs has drastically changed because the UI was part of an application that had its own lifecycle. Development of the server and the client application often took place separated. The HTTP API often played the role of an informal contract between client and server.

\subsection{UI web development today}\label{uidevelopmenttoday}

To this day a lot of UIs are developed that way. Some parts are increasingly rendered on the server again, mainly for performance and search engine optimization. It is common to have a \textbf{frontend} team working on the client and a \textbf{backend} team working on the server. The frontend team makes sense of the data that comes from the server either manually or in the best case using some form of HTTP API documentation.
\\ There are efforts like Swagger or OpenAPI to formalize and standardize documentation of HTTP APIs. Often documentation can be generated to a certain extent, so the overhead to keep the up-to-date is small. Documentation helps \textbf{humans} (frontend team) to understand the data and to develop a client that consumes the documented API in an efficient and effective way.
\\ Nevertheless, data coming from the server has to be understood by human frontend developers. That interpretation of the meaning of the incoming data is hard coded into the client and the UI. This causes strong coupling of the client to the data and therefore to the server. The client can not be re-used in some other \textbf{context}.

\subsubsection{Lack of context}\label{datahumanmachine}

Picture a scenario in everyday life where two good friends meet. One of them says: \textit{Have you heard about Frank? He recently got married.} Chances are high the other one knows multiple people named \textbf{Frank}. Being a human, he is able to map the name \textbf{Frank} to the person the other one is referring to. He is able to do so, because that conversation has an implicit context. That context is the intersection of the sets of people \textbf{both know}.
\par Exactly the same thing happens frequently in software development, especially in data exchange. A frontend developer looks at either all HTTP routes of an API or glances over the documentation. Sometimes he is able to \textbf{infer} the domain model because of his personal experiences as a human. If that developer is not familiar with the domain at all, maybe because the domain is niche, he has trouble understanding the data coming from the server. He perceives development to be difficult and he is not able to put the data being exchanged into a \textbf{context}.
\par What makes the life of a human developer hard, poses an insurmountable obstacle to a machine. A machine doesn't have dozens of years of life experience to draw from when trying to understand data.\footnote{Here we talk about machines in the sense of contemporary information systems. Systems that are able to learn are deliberately ignored as they haven't been proven to be useful in this context.} The machine has to be fed a context together with the data it should understand. In traditional web UI development that context is hard coded into the client and the UI. The author believes that the majority of work done in UI development could be eliminated by \textbf{exchanging data that has meaning attached to it}.

\subsection{Linked data}\label{linkeddata}

Linked data is a way of creating a web of machine interpretable data across different domains, systems and organizations. A person or a machine should be able to explore data by simply following links. In essence, the same expectations apply to make that web of data grow as to linked HTML documents: \citep{linkedatafourrules}

\begin{enumerate}
  \item Use URIs as names for things
  \item Use HTTP URIs so that people can look up those names.
  \item When someone looks up a URI, provide useful information, using the standards (RDF*, SPARQL)
  \item Include links to other URIs, so that they can discover more things.
\end{enumerate}

A machine looking at a piece of linked data follows the links and is able to unambiguously understand the data.

TODO small example using RDF

\lstset{language=XML}
\begin{lstlisting}
<rdf:Description about="#albert"
 <fam:child rdf:Resource="#brian">
  <fam:child rdf:Resource="#carol">
  </rdf:Description>
\end{lstlisting}

\subsection{JSON-LD}\label{jsonld}

TODO valid JSON, only @id and @context, network effect, tooling, check spec

\lstset{language=JSON}
\begin{lstlisting}
{
  "name": "Myth of Sisyphus",
  "author": "Albert Camus",
  "location": "http://amazon.com/Myth-Sisyphus-Albert-Camus/dp/7500133340/",
  "image": "http://ecx.images-amazon.com/images/I/61hJVrZgBBL.jpg"
}
\end{lstlisting}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut ut congue nisl. Maecenas nec odio eget felis ultricies consequat. Vestibulum consequat orci eu augue sodales rhoncus. Sed tempor maximus nisl, in varius eros mollis tempus. Praesent condimentum nibh eros. Maecenas pulvinar massa ut lectus volutpat, ac mattis ligula laoreet. Duis cursus odio a quam ullamcorper, lacinia dignissim magna lobortis. Phasellus nec lectus sit amet elit convallis interdum. Ut at est risus.

Curabitur finibus laoreet mauris at molestie. Nunc arcu est, vulputate sit amet tempus vitae, sagittis in elit. Vestibulum ac pretium justo, vehicula vestibulum lacus. Pellentesque varius mattis aliquet. Vestibulum a lacus placerat, faucibus neque sed, hendrerit ante. Etiam id suscipit odio. Vivamus porta sollicitudin metus, in pulvinar lorem maximus et. Pellentesque eget sodales lacus, et convallis augue. Fusce porta leo et posuere cursus.

\subsubsection{Framing}\label{jsonldframing}

TODO describe operation and what the goal is

\subsubsection{Compacting}\label{jsonldextending}

TODO describe operation and what the goal is

\subsubsection{Extending}\label{jsonldextending}

TODO describe operation and what the goal is

\subsection{Hypermedia vocabulary}

TODO glory of rest

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut ut congue nisl. Maecenas nec odio eget felis ultricies consequat. Vestibulum consequat orci eu augue sodales rhoncus. Sed tempor maximus nisl, in varius eros mollis tempus. Praesent condimentum nibh eros. Maecenas pulvinar massa ut lectus volutpat, ac mattis ligula laoreet. Duis cursus odio a quam ullamcorper, lacinia dignissim magna lobortis. Phasellus nec lectus sit amet elit convallis interdum. Ut at est risus.

\subsubsection{Hydra}

TODO check spec

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut ut congue nisl. Maecenas nec odio eget felis ultricies consequat. Vestibulum consequat orci eu augue sodales rhoncus. Sed tempor maximus nisl, in varius eros mollis tempus. Praesent condimentum nibh eros. Maecenas pulvinar massa ut lectus volutpat, ac mattis ligula laoreet. Duis cursus odio a quam ullamcorper, lacinia dignissim magna lobortis. Phasellus nec lectus sit amet elit convallis interdum. Ut at est risus.

Curabitur finibus laoreet mauris at molestie. Nunc arcu est, vulputate sit amet tempus vitae, sagittis in elit. Vestibulum ac pretium justo, vehicula vestibulum lacus. Pellentesque varius mattis aliquet. Vestibulum a lacus placerat, faucibus neque sed, hendrerit ante. Etiam id suscipit odio. Vivamus porta sollicitudin metus, in pulvinar lorem maximus et. Pellentesque eget sodales lacus, et convallis augue. Fusce porta leo et posuere cursus.

\subsubsection{Schema.org}

TODO check spec

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut ut congue nisl. Maecenas nec odio eget felis ultricies consequat. Vestibulum consequat orci eu augue sodales rhoncus. Sed tempor maximus nisl, in varius eros mollis tempus. Praesent condimentum nibh eros. Maecenas pulvinar massa ut lectus volutpat, ac mattis ligula laoreet. Duis cursus odio a quam ullamcorper, lacinia dignissim magna lobortis. Phasellus nec lectus sit amet elit convallis interdum. Ut at est risus.

Curabitur finibus laoreet mauris at molestie. Nunc arcu est, vulputate sit amet tempus vitae, sagittis in elit. Vestibulum ac pretium justo, vehicula vestibulum lacus. Pellentesque varius mattis aliquet. Vestibulum a lacus placerat, faucibus neque sed, hendrerit ante. Etiam id suscipit odio. Vivamus porta sollicitudin metus, in pulvinar lorem maximus et. Pellentesque eget sodales lacus, et convallis augue. Fusce porta leo et posuere cursus.

\subsection{Existing solutions and tools}

\subsubsection{GraphQL}
\subsubsection{Rails with ActiveAdmin}
\subsubsection{Hyperfiddle}
\subsubsection{Fulcro}
