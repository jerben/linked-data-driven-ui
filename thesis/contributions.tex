\section{Main contributions}\label{contributions}
The main contribution of this thesis is the theoretical foundation of a new approach to UI development that reduces development costs.

\paragraph{Scope}\label{sec:scope}
The scope of this thesis includes following artifacts:

\begin{itemize}
\item a hypermedia vocabulary and HATEOAS specification
\item implementations of two HTTP APIs using that HATEOAS specification
\item a brief evaluation of design languages
\item a proof of concept of a the UI framework
\end{itemize}
The choice of the HATEOS specification is driven by the implementation of the HTTP APIs. The development of the HTTP APIs is driven by use cases that resemble real world scenarios. The UI framework is used to create a client that can consume both HTTP APIs which conform to that HATEOAS specification.

\subsection{Methods}
This sections describe the methodological approach to achieve the items listed in the paragraph \ref{sec:scope}.

\subsubsection{General approach}
This thesis is structured in three parts.

\begin{enumerate}
\item The first part is concerned with research of HATEOAS vocabularies and specifications and the evaluation of design languages. This includes research of the use of hypermedia, linked data and web components. The goal is to gather research results that may serve as foundation of this thesis.
\item The second part defines two real-world use cases for web applications. By looking at the deficits of contemporary solutions for UI development we define design goals for the UI framework. We summarize the insights gained by implementing an HTTP API for each use case and by developing the UI framework. This part follows best practices from agile software development - we develop the UI framework in two iterations.
\item The last part evaluates the UI framework by analyzing its impact on software complexity. Furthermore we assess whether the design goals were met and we give an outlook on future work.
\end{enumerate}

\subsubsection{Use of scores}
In order to evaluate the UI framework and its concepts we are using two scoring systems. To asses whether goals have been met scores between 0 and 3 are used. To gauge how complexity has been effected we use scores between -3 and 3.

\begin{table}[]
  \begin{center}
    \begin{tabular}{|c|l|}
      \hline
      Score & Effect on goal \\
      \hline
      0 & Goal not met \\
      1 & Slight improvement towards goal \\
      2 & Goal mostly met \\
      3 & Goal completely fulfilled \\
      \hline
    \end{tabular}
    \caption{Scores to evaluate whether goals have been met}
  \end{center}
\end{table}

\begin{table}[]
  \begin{center}
    \begin{tabular}{|c|l|}
      \hline
      Score & Effect on complexity \\
      \hline
      -3 & Massive increase in complexity \\
      -2 & Increase in complexity \\
      -1 & Slight increase in complexity \\
      0 & No change in complexity \\
      1 & Slight decrease in complexity \\
      2 & Decrease in complexity \\
      3 & Massive decrease in complexity \\
      \hline
    \end{tabular}
    \caption{Scores to gauge the change in complexity}
  \end{center}
\end{table}

\subsubsection{Steps}
This section lists and describes the steps that we take in this thesis.

\paragraph{Conceptual analysis of user interfaces}
Before defining the use cases we analyze UIs on a conceptual level. By looking at typical usage patterns of users we describe the concepts of UIs. We aim to identify components that can be researched and implemented independently in smaller iterations.

\paragraph{Hypermedia vocabulary and HATEOAS specification}
This section explores hypermedia vocabularies and HATEOAS specifications. By listing requirements that such a specification has to fulfill we either create our own HATEOAS specification, use an existing one or mix bits and pieces of existing ones.

\paragraph{Evaluation of design languages and their implementations}
We evaluate popular design languages and their implementations. The UI generation is based on top of an existing design language so that best practices in design and presentation of UIs are respected. Design languages are not in the scope of this thesis - the UI framework uses existing implementations.

\paragraph{Definition of major design goals}
Major design goals of the UI framework are directly influenced by non-functional requirements. We consider the broader scope of UI development in order to obtain those. This includes analysis of:

\begin{enumerate}
  \item the development process of UIs with web technologies
  \item contemporary frameworks and tools for UI development that enjoyed wide and rapid adoption
  \item contemporary frameworks and tools for UI development that failed
\end{enumerate}

By following what tools in \textbf{2} did right and avoiding the mistakes of tools in \textbf{3}, we define a set of design goals that the proof of concept should adhere to. We refer to the solutions and tools researched in section \ref{sec:contemporarysolutions}.

\paragraph{Specification of the proof of concept}
The section defines the architecture and design of the proof of concept. The proof of concept should demonstrate the viability of the thesis.

\paragraph{Definition of real world use cases}
By defining real world applications for the UI framework we discover user roles and user stories.

\paragraph{Implementation of proof of concept driven by use cases}
The UI framework is developed incrementally use case by use case. The major design goals are respected. We expect to gain theoretical insights while implementing both the UI framework and the HTTP APIs.

\paragraph{Evaluation of design goals}
We analyze the design goals and whether they have been met. We assess each design goal qualitatively and assign a score between 0 and 3.

\paragraph{Conclusion of approach to reduce development costs}
We break up software complexity into specific types Accidental Complexity and Essential Complexity. Both types are broken down further and the effect of using the UI framework is analyzed. We asses the change in complexity with a score between -3 and 3.

\subsection{Conceptual analysis of user interfaces}
For a system to be useful, it has to interact with its environment. These interactions happen through multiple types of interfaces, which are used by two types of users. The users are either other systems or human users.
Interfaces for human users (user interfaces) have typical characteristics. By observing their usage we can analyze the main characteristics. A typical scenario of UI usage is browsing a website. What does the user do while browsing a website? It is typically one of two things: he either reads or clicks.

The usage of a UI by a user consists of either \textbf{reading} or \textbf{interacting}. In terms of systems we can call them \textbf{querying} or \textbf{interacting} respectively.

\begin{enumerate}
  \item Query: The user is able to retrieve information from the UI by looking at it
  \item Interacting: The user is able to interact with the UI
\end{enumerate}

The development of the UI framework is driven by the implementation of these two capabilities. We define a use case for each of them.

\subsection{HATEOAS API specifications}
The goal is to pinpoint a specification among existing HATEOAS API specifications. The real world uses cases will implement HTTP APIs that conform to this specification. The client that consumes such a API is merely a console. This implies the client doesn't contain any knowledge about the API implementation. It is sufficient to implement the specification. \\
Following requirements have to be addressed by the chosen specification:

\paragraph{Self documenting}
The API should provide its own documentation so the consumer doesn't have to use a third party tool. This requires a mechanism to attach meta data to the response payload.

\paragraph{Discoverability}
The consumer should be able to autonomously discover the data model of an API.

\paragraph{Actions and Operations}
The API should provide a description on how to interact with it. Ideally the API publishes the data that is needed by the client to build action objects or operations that can be invoked.

\paragraph{Uses linked data}
Based on the discussion in section \ref{linkeddata} about the benefits of linked data, this thesis explores linked data as key component to efficient UI development. In combination with the web component based rendering discussed in section \ref{webcomponents} it allows UI developers to think in terms of components and data.

\subsubsection{Hydra}
It is remarkable that at the time of writing only one HATEOAS specification exists that satisfies the requirements stated above.

\href{http://www.hydra-cg.com/}{Hydra} is a lightweight specification to create hypermedia-driven Web APIs. By specifying a number of concepts commonly used in Web APIs it enables the creation of generic API clients \citep{hydraspecs}. At the time of writing the Hydra specification exists only as an unofficial draft.

The two major benefits of APIs supporting hypermedia are \textbf{discoverability} and \textbf{self documentation}. \\
\paragraph{Discoverability} Discoverability is given by the RESTful nature of any hypermedia API. The API provides an entry point and each resource describes the means to fetch other resources. The client is able to traverse the API by understanding the response and sending requests to the server - there is no external documentation needed. All resources that the client is concerned with it can reach.

\paragraph{Self documentation}
Hydra documents itself by providing meta data along the payload. \\
It can use the same data model for generating built-in documentation and serving the API. These documentations less likely to become out-of-date and the maintenance cost is low..

Every Hydra resource has a documentation attached to it. By default the response contains the \textbf{Link} header of the URL to the documentation.

\paragraph{Collections, partial views and pagination}
In the world of Hydra there are conceptually only \textit{things} and \textit{lists of things}. There is no list of list of things. \\
Hydra calls a list of things \textbf{collection}, which can have things as members. There is the concept of a \textbf{partial view}. This gives the client the ability to fetch a subset of a collection. That partial view can be controlled by client initiated \textbf{pagination}. The client provides a limit and an offset when requesting a collection in order to initiate pagination.

\paragraph{Operations}
In order to interact with the server a client has to know which operations the server supports. Hydra exposes all information necessary to build and invoke operations. This allows any client that understands Hydra to interact with such API without any prior knowledge about the concrete API implementation. \\
This part is not fully specified yet at the time of writing. The author had to directly communicate with Hydra core members and reverse engineer tools in the Hydra ecosystem in order to understand how Hydra operations are supposed to work.

\subsection{Design languages}
A design language or design vocabulary is an overarching scheme or style that guides the design of a complement of products or architectural settings. Designers wishing to give their suite of products a unique but consistent look and feel define a design language for it, which can describe choices for design aspects such as materials, colour schemes, shapes, patterns, textures, or layouts. They then follow the scheme in the design of each object in the suite. \citep{designlanguage}

The benefit of the use of a design language is the consistent look and feel of UIs that \textbf{are composed of a set of small components}. Additionally it frees the UI developer from cumbersome work like making sure that the UI is responsive and behaves well on various screen sizes. UI developers can communicate and think in a higher level of abstraction by omitting implementation details that are taken care of by design language implementations. As an example, it allows thinking about \textbf{small buttons horizontally next to each other} instead of considering the actual implementation of those horizontally aligned buttons in CSS.

The major design languages are built on top of years of research in Human-computer interaction. Evaluation of the theoretical foundation is not in the scope of this thesis. We aim to benefit off the implementations and tools.

\subsubsection{Design language implementations}
The UI framework will consume React components and it will internally use React as well. The only requirement for the design language implementation is the use of React.

\paragraph{Material Design}
Material Design was developed at Google in 2014. Initially it was used in Google's own mobile apps and in the mobile OS Android. In order to offer a consistent user experience across all products Google uses it in web products as well.

The React implementation of Material Design is called Material UI. It bottles up the UX best practices and provides them in form of React components. \\
By implementing a simple form with three text fields and a button we conclude that Material UI is too heavyweight. It is not always obvious how to configure components - especially big ones. The main contribution of Material Design and Material UI are best practices in mobile UX. This reaches beyond simple forms and visualization of lists. Material Design dictates the look and feel of menus and navigations as well. \\
The UI Framework requires a lower level design language implementation that doesn't make assumptions or and doesn't state rules about larger components and UX.

\paragraph{Semantic UI}
Semantic empowers designers and developers by creating a shared vocabulary for UI. \citep{semanticui} This thesis explores the benefits of shared vocabularies in HTTP APIs. Semantic UI is not as widely adopted as Material Design. Its React implementation has a level of abstraction that fits generically rendering forms and navigations.

\begin{figure}[!htb]
  \includegraphics[width=150pt]
    {images/materialdesign.png}
  \includegraphics[width=320pt]
    {images/semanticui.jpg}
  \caption{Material Design on a mobile device (left) and Semantic UI components (right). (Source: https://wikipedia.org, https://www.sketchappsources.com/)}
\end{figure}

We pick Semantic UI and its React implementation.

\subsection{Design goals}\label{sec:designgoals}
Following design goals should be met by the UI framework. For each design goal we discuss the goal itself, why and how we intend to meet it and how it can be measured.
The goals are partly derived by analyzing the deficits of contemporary tools to enhance UI and web development.

\subsubsection{Play nicely with others}\label{sec:playnice}
As discussed in section \ref{graphql} the fact that GraphQL doesn't play well with other is one of its major weaknesses. Playing nicely with others is the most important design goal of the UI framework because it allows to reuse and build on top of existing research and work.
It is important to respect standards and stay compatible with existing tooling. This design goal drove the choice of JSON-LD as serialization format for linked data.

We acknowledge the widespread use of HTTP and JSON as data exchange format and achieve this design goal by conforming to web standards and \textbf{extending} existing tooling. JSON-LD allows us to stay compatible with all tools consuming and producing JSON.

This design goal can be quantified by analyzing each component of the UI framework and determine whether the technologies, protocols, languages and tools for that component are either formally standardized or a defacto standard.

\subsubsection{Straightforward upgrade path}
In order to help the adoption of the UI framework it is important to show a clear upgrade path and to keep the friction at a minimum.

This can be achieved by \textbf{extending} existing standards, keep breaking changes at a minimum and with good documentation. Playing nicely with others helps to reach this design goal as well.

This design goal can be quantified by measuring or estimating the effort that needs to be spent to upgrade a conventional API to the suggested hypermedia API.

\subsubsection{Customizability}
While providing sane defaults, the UI framework should be customizable. There should be no limitations imposed in terms of what UIs can be drawn.

We want to achieve this goal be allowing the UI developer to override the sane defaults. The UI developer can decide to completely ignore the linked data aspect and consume the HTTP API in a traditional way by hard coding knowledge into the client. The use of React as UI library allows the UI developer to pull in external React components.

This design goal is met if all possible UIs that can be drawn with conventional tools can be drawn using the UI framework. By allowing the UI developer to consume the hypermedia API as conventional API this goal is met.

\subsubsection{Developer ergonomics}
The UI developer should be able to use the UI framework with spending minimal effort on learning.

This goal can be achieved by choosing a widely used platform that has a striving open source community. It is important that there is an open source community working on that platform because a wide adoption behind closed doors is less likely to improve developer ergonomics.
A big market share of the platform increases the chances that the developer is already familiar with it. The tooling of these platforms tends to be polished and battle tested. The developer is less likely to get stuck because of some edge case issues.

An established and widely adopted platform is Node and the NPM (Node Package Manager) ecosystem. This is the platform that we choose to develop the UI framework in.

\subsection{Proof of concept of UI Framework}\label{proofofconcept}
We define two real-world use cases that cover the two main capabilities of \textbf{rendering data} and \textbf{user interaction}. Each of those use cases are split up into user stories that can be implemented separately. This ensures that the design goals are met and all user roles are considered.

The proof of concept of the UI Framework consists of following components:

\paragraph{Hydra client}
The Hydra client is a wrapper around the Hydra HTTP API. It takes care of serializing Hydra resources, fetching Hydra documentation and invoking operations. The value it provides to us is mainly developer ergonomics. The most complete Hydra client is called Alcaeus which we are using as a part of the UI Framework.

\paragraph{Infrastructure}
The infrastructure allows UI developers to plug in their own components as renderers, it fetches data from the server using the Hydra client and it applies the renderers by providing them the data returned by the Hydra client. This component is the glue - it knows all other components.

\paragraph{JSON-LD Renderer}
The JSON-LD renderer is one of the two renderers that ship be default with the UI Framework. It's only purpose is to render the JSON-LD response from the server. Rendering JSON-LD is equivalent to rendering tree like data.

\paragraph{Hydra Renderer}
The Hydra renderer is the second renderer that ships with the UI Framework. It builds on top of the JSON-LD renderer and it renders root resources, collections, links and operations. The Hydra Renderer creates a UI on top of a Hydra API which a user can use to interact. That UI is not optimized for efficiency because there is no domain knowledge involved.

\paragraph{Domain Renderers}
This component describes the set of renderers are contributed by the UI developer. They contain domain knowledge and are only valid for certain data types. As discussed in section \ref{uidevelopmenttoday} contemporary clients and the web UIs they include are tightly coupled to HTTP APIs. The reason is the hard coded knowledge in the UIs about the domain models and rules. \\
The Domain Renderers render linked data instead of any data. This means the linked data provides its own context, the UI developer doesn't hard code assumptions about the data model of the HTTP API - only about the linked data. \\
A React component and a linked data type constitute one domain specific renderer. The open-world philosophy of linked data encourages reuse across company, department and team boundaries. Domain renderers can be shared together with vocabulary since they are not coupled to data models \textbf{but to linked data vocabularies}.

\paragraph{Semantic UI}
Semantic UI is a set of reusable React components that constitutes the bottled up best practices of UI and UUX.

\begin{figure}[!htb]
  \center{\includegraphics[width=400pt]
    {images/ui-framework-architecture.png}}
  \caption{The architecture of the proof of concept of the UI Framework.}
\end{figure}

\subsection{Use Case 1: Apartment}\label{sec:usecase1}
For the user to be able to query data the UI has to render it.

The first use case describes a scenario in home automation. Several thermometers in rooms in an apartment send the current temperature to a server. The goal is to develop a UI that displays apartments, rooms, and thermometers and temperatures in a sensible manner.

\subsubsection{Requirements}

TODO fix data model diagram, make it nicer
\begin{figure}[!htb]
  \center{\includegraphics[width=100pt]
    {images/iot.png}}
  \caption{Data model of the apartment use case.}
\end{figure}

\begin{table}
  \begin{center}
    \begin{tabular}{ |c|l| }
      \hline
      ID & Story title \\
      \hline
      S01 & As landlord I want to overview my apartments \\
      S02 & As landlord I want to overview all rooms of an apartment \\
      S03 & As landlord I want to overview thermometers of room \\
      S04 & As landlord I want to overview the measurement data of a thermometer \\
      S05 & As landlord I want to intuitively see the temperatures on a floor plan \\
      S06 & As UI developer I want to present all available data without spending any development time \\
      S07 & As UI developer I want to be able to customize the UI in order to improve it incrementally \\
      \hline
    \end{tabular}
    \caption{User stories of a client that consumes a home automation API}
    \label{tab:usecase1}
  \end{center}
\end{table}

\subsubsection{Hydra collection rendering}
Due to the data model the API exposes a collection of apartments, rooms and thermometers. Every Hydra API has an entry point and a set of root collections. These collections can be used as starting point to discover the API.

Hydra has native support for collections by using the property \lstinline{http://www.w3.org/ns/hydra/core#member}.

\lstset{language=JSON}
\begin{lstlisting}[caption=Data of /rooms as Hydra collection.]
  {
    "@context": "http://localhost:3000/iot/contexts/Room",
    "@id": "http://localhost:3000/iot/rooms",
    "@type": "Collection",
    "totalItems": 6,
    "member": [
      {
        "@id": "http://localhost:3000/iot/rooms/0",
        "@type": "https://schema.org/Room",
        "amenityFeature": "Kitchen",
        "containsPlace": [],
        "containedInPlace": "http://localhost:3000/iot/apartments/0",
        "geo": {...}
      },
      {
        "@id": "http://localhost:3000/iot/rooms/1",
        "@type": "https://schema.org/Room",
        "amenityFeature": "Laundry Storage",
        "containedInPlace": "http://localhost:3000/iot/apartments/0",
        "geo": {...}
      },
      ...
    ]
  }
\end{lstlisting}

Each member of this collection is of type \lstinline{https://schema.org/Room}. The properties can be looked up by following the URL of the type. Given every member of the collection is of the same type, we can implement a generic renderer that looks up the properties of the member type and renders the collection as a table.

\begin{figure}[!htb]
  \center{\includegraphics[width=500pt]
    {images/hydra-collections.png}}
  \caption{Generic table renderer applied on root collections.}
\end{figure}

The \lstinline{@id}s are rendered as links so that the API can be traversed by looking up resources and collections of resources.

\subsubsection{Plugin mechanism}\label{pluginmechanism}
As shown in section \ref{proofofconcept} the architecture of the UI Framework support custom renderers as main mechanism to override default behavior. The UI developer starts out with the default set of renderers that can render arbitrary JSON-LD data and data coming from a Hydra API. \\
The fact that the API returns linked data benefits this customization process. The UI developer only cares about how to render \textbf{certain data types}. In our use case he might be concerned with rendering the data type \lstinline{Temperature}.

We demonstrate data rendering using the room called \textbf{Entrance}. The trivial JSON-LD renderer colors property keys red, properties that represent relationships blue and it renders \lstinline{@id}s as hyperlinks.

\begin{figure}[!htb]
  \center{\includegraphics[width=380pt]
    {images/json-ld-renderer.png}}
  \caption{JSON-LD renderer applied on the data of /rooms/4.}
\end{figure}

This room contains a list of things of type \lstinline{Thermometer} and \lstinline{https://schema.org/Place}. The thermometer as a custom \lstinline{https://schema.org/additionalProperty} that as the name \textbf{Temperature} and a numeric value. \\ This is not straightforward to see as the JSON-LD is visually noisy. By applying a custom renderer to \lstinline{https://schema.org/additionalProperty} we render the temperature in one line with an icon indicating whether the temperature is hot or cold. This however requires domain knowledge since these differentiation holds only true in this context of room temperatures.

Considering the UI developer's workflow, the UI Framework expects a React component that takes the data of the \lstinline{https://schema.org/additionalProperty} and returns markup. The renderer that can be registered in the UI Framework comprises of a unique id, a name, a React component and a type. The type is used by the rendering infrastructure to determine which renderers to apply on what part of the server response.

\lstset{language=JSON}
\begin{lstlisting}[caption=Renderer configuration that the developer provides.]
  {
    id: "thermometer",
    name: "Thermometer",
    comp: (data) => <Thermometer/>,
    type: "http://localhost:3000/iot/apartments/Thermometer"
  }
\end{lstlisting}

\begin{figure}[!htb]
  \center{\includegraphics[width=380pt]
    {images/temperature-renderer.png}}
  \caption{The temperature renderer is applied on \lstinline{additionalProperty}. on top of the JSON-LD renderer.}
  \label{fig:temperature}
\end{figure}

It is noteworthy that renderer compose by stacking them on each other. As shown in figure \ref{fig:temperature} the temperature renderer works on top the JSON-LD renderer.

By implementing similar renderers for rooms and thermometers we achieve a UI as show in figure \ref{fig:rooms}.

\begin{figure}[!htb]
  \center{\includegraphics[width=500pt]
    {images/room-renderer.png}}
  \caption{Apartment data with active renderers: JSON-LD, Thermometer, Temperature, Room.}
\end{figure}

\subsubsection{Domain rendering}
Both the JSON-LD renderer and the Hydra renderer come with the UI Framework pre-configured. Internally both are registered using the plugin mechanism. Activating both renderers leads to a UI that is \textbf{correct} \footnote{Here we use the term \textbf{correct} in the sense of correct data rendering - the UI doesn't show wrong or non-existing data and it shows all of the response data.} and the user is able to navigate through the API using hyperlinks. This rendering setup is decoupled from the API implementation, the only requirement it has is the conformity to Hydra.

In order to leverage domain information for visualizing data the UI developer has to provide custom components that contain domain knowledge. We demonstrate domain rendering by looking at one apartment.

The thermometer renderer removes some noise by compacting the thermometer data. The room renderer removes some properties that are not important in this context and it draws a box around the room so rooms are easier to distinguish. This list view provides all information to the landlord that he cares about. \\ Places and containment relationships of places can be visualized in a more intuitive way.

\paragraph{Floor plan}
The apartment has a property called \lstinline{https://schema.org/hasMap}.

\lstset{language=JSON}
\begin{lstlisting}[caption=The \lstinline{hasMap} property of apartment /apartments/0.]
...
  "hasMap": {
  "@type": "https://schema.org/URL",
  "@id": "http://localhost:3000/iot/floorplan.jpg"
}
...
\end{lstlisting}

This property has a link to an image representing the floor plan of the apartment.

\paragraph{Geo coordinates}
All things of type \lstinline{https://schema.org/Apartment} and \lstinline{https://schema.org/Room} can have a \lstinline{geo} property.

\lstset{language=JSON}
\begin{lstlisting}[caption=The \lstinline{https://schema.org/geo} property of apartment /apartments/0.]
...
  "geo": {
    "@type": "https://schema.org/GeoCoordinates",
    "longitude": 10,
    "latitude": 7
  }
...
\end{lstlisting}

This property contains the longitude and latitude coordinates of the center of the place.

Both properties \lstinline{https://schema.org/hasMap} and \lstinline{https://schema.org/geo} are defined on the type \lstinline{https://schema.org/Place}. \lstinline{https://schema.org/Apartment} is a subtype of \lstinline{https://schema.org/Place} in the schema.org hierarchy, so our apartment renderer has to expect the existence of those properties.

By leveraging coordinates of the places and the floor plan of the apartment we use domain knowledge to implement a renderer that provides additional value to the landlord. By rendering the rooms on the floor plan the landlord can grasp the locations of thermometers in a more natural way.

\begin{figure}[!htb]
  \center{\includegraphics[width=500pt]
    {images/apartment-renderer.png}}
  \caption{Apartment data with active renderers: JSON-LD, Thermometer, Temperature, Room, Apartment, BoldFont.}
  \label{fig:apartmentrenderer}
\end{figure}

It is noteworthy that a set of renderers can be active at the same time. Whenever the rendering infrastructure encounters a data type that has a registered renderer it will apply it. In this example Hydra collections are still rendered as tables if the landlord opens the collection of rooms or thermometers.

\subsubsection{Verification of user stories}
In this section we verify that the user stories listed in table \ref{tab:usecase1} are fulfilled by either accepting or rejecting them.

\begin{table}
  \begin{center}
    \begin{tabular}{ |c|l| }
      \hline
      ID & Accepted/Rejected \\
      \hline
      S01 & Accepted: The landlord can overview the apartments \\
      S02 & Accepted: The landlord can list all rooms of an apartment \\
      S03 & Accepted: The landlord can list all thermometers of a rooms \\
      S04 & Accepted: The landlord can see the temperature reported by a thermometer \\
      S05 & Accepted: The landlord can overview the location of the temperatures on the floor plan \\
      S06 & Accepted: The UI developer uses the default renderers to render a correct UI \\
      S07 & Accepted: The UI developer can register custom renderers to improve the UI incrementally \\
      \hline
    \end{tabular}
    \caption{All user stories are fulfilled and the first use case is implemented.}
  \end{center}
\end{table}

\subsection{Use Case 2: Kanban Board}
The second use case describes a typical scenario in project management. We use this use case to explore the viability of Hydra for UIs with user interaction. A project has multiple issues which represent chunks of work. Issues can be in one of the following statuses:

\subsubsection{Requirements}

\begin{enumerate}
  \item Backlog: Status of an issue that need additional input before it can be worked on.
  \item Ready: Status of an issue that has well defined requirements - enough information is available to start implementation.
  \item In process: Status of an issue that is being worked on.
  \item Done: Issues that have been implemented.
\end{enumerate}

\begin{figure}[!htb]
  \center{\includegraphics[width=400pt]
    {images/state-diagram.png}}
  \caption{Status workflow of an issue.}
  \label{fig:statetransition}
\end{figure}

Figure \ref{fig:statetransition} shows all possible statuses and status transitions of an issue. It is noteworthy that once an issue is ready it can not be put back to the backlog and similarly an finished issue can not be undone.

TODO fix data model diagram, make it nicer and correct
\begin{figure}[!htb]
  \center{\includegraphics[width=100pt]
    {images/kanban.png}}
  \caption{Data model of the home automation use case.}
\end{figure}

\begin{table}
  \begin{center}
    \begin{tabular}{ |c|l| }
      \hline
      ID & Story title \\
      \hline
      S01 & As project manager I want to overview all projects \\
      S02 & As project manager I want to overview all issues of a project \\
      S03 & As project manager I want to see the status of an issue \\
      S04 & As project manager I want to change the status of an issue \\
      S05 & As project manager I want to remove issues \\
      S06 & As a project manager I want to change the issue status by drag and drop \\
      S07 & As UI developer I want to present all available data without spending time \\
      S08 & As UI developer I want to be able to customize the UI in order to improve it incrementally \\
      S09 & As UI developer I want to have an interactive UI without spending time \\
      \hline
    \end{tabular}
    \caption{User stories of a simple home automation dashboard.}
    \label{tab:usecase2}
  \end{center}
\end{table}

\subsubsection{User interaction}
Hydra supports user interaction through operations. The server tells the client how to build an operation which the client then can invoke. Hydra supports three types of operations:

\paragraph{Inline operations}
The actual data is augmented with a list of supported operations. The resource has a property \lstinline{supportedOperations} where the resource is the operation object \footnote{The subject invokes the operation on an object}.

\paragraph{Attached to supported properties}
Hydra supports documentation of properties. This documentation might include information about which values are valid. It is possible to attach operations to those property documentations.

\paragraph{Attached to supported classes}
Similar to the concept of supported properties it is possible to document classes. Classes are used to group things together that are used the same way in certain contexts. Classes can be assigned to things by using the \lstinline{@type} property.

We choose the last approach to attach operations to issues based on their status.

\subsubsection{State transition as Hydra operations}
This section discusses the HTTP API implementation of the issue status change actions. The goal is to implement the state transition shown in figure \ref{fig:statetransition}.

\paragraph{Hydra classes}\label{par:classes}
Each status that has outgoing state transitions maps to a Hydra class. We have the classes \lstinline{BacklogIssue}, \lstinline{ReadyIssue}, \lstinline{InProcessIssue}. Note that there is no class for an issue that is done because according to the status transitions there is no way to change the status of an issue that is done.

Each \textbf{out going} status transitions are represented by Hydra classes as well. Our API documentation contains \lstinline{IssueToReadyUpdate}, \lstinline{IssueToInProcessUpdate}, \lstinline{IssueToDoneUpdate} as additional classes. There is no \lstinline{IssueToBacklogUpdate} because according to the state transitions it is not possible to undo issue planning.

\paragraph{Supported operations}
Each issue class supports a list of operations. Translation of the state transition diagram \ref{fig:statetransition} and mapping of the Hydra classes defined in \ref{par:classes} to the states and state transitions leads to the state transition matrix shown in \ref{tab:statetransitionmatrix}.

\begin{table}
  \begin{center}
    \begin{tabular}{ |c|l| }
      \hline
      Status class & Operation classes \\
      \hline
      BacklogIssue & IssueToReadyUpdate, IssueToInProcessUpdate, IssueToDoneUpdate \\
      ReadyIssue & IssueToInProcessUpdate, IssueToDoneUpdate \\
      InProcessIssue & IssueToReadyUpdate, IssueToDoneUpdate \\
      \hline
    \end{tabular}
    \caption{State transition matrix of issue stati.}
    \label{statetransitionmatrix}
  \end{center}
\end{table}

\lstset{language=JSON}
\begin{lstlisting}[Exempt of the Hydra documentation showing the list of supported operations for the issue status class \lstinline{ReadyIssue}]
  ...
  {
    "@id": "http://localhost:3000/kanban/issues/ReadyIssue",
    "@type": "Class",
    "title": "Issue that is ready",
    "description": "An issue which is ready and can be started.",
    "supportedOperation": [
      {
        "@type": "http://schema.org/UpdateAction",
        "method": "POST",
        "label": "Start",
        "expects": "http://localhost:3000/kanban/issues/IssueToInProcessUpdate",
        "returns": null
      },
      ...
    ]
  },...
\end{lstlisting}

\subsubsection{Generically rendering operations}

Similar to the first use case in \ref{sec:usecase1} the list of issues is rendered using the \textit{Hydra renderer}. The issue properties like \lstinline{description} and \lstinline{title} are columns in a table. The last column is used for the Hydra operations in case any of the issues (table rows) has at least one supported operation.

Operations have \lstinline{method} property so the client knows how to invoke that operation. We use this information to render buttons for issue removal and issue status change differently.

\begin{figure}[!htb]
  \center{\includegraphics[width=470pt]
    {images/issues-hydra-renderer.png}}
  \caption{Collection of issues rendered by the Hydra renderer.}
  \label{fig:issueshydra}
\end{figure}

A click on a a \textbf{start} status change button shown in \ref{fig:issueshydra} causes the Hydra client to invoke the operation. The client fetches \lstinline{http://localhost:3000/kanban/issues/IssueToInProcessUpdate} and sends a POST request to the URL of the issue in that row.

\subsubsection{Domain rendering}
Using the plugin mechanism we have implemented in \ref{pluginmechanism} we implement a domain specific renderer that interprets this list of issues as a Kanban board. Figure \ref{fig:kanbanrenderer} shows issues grouped by their status on a Kanban board.

\begin{figure}[!htb]
  \center{\includegraphics[width=470pt]
    {images/kanban-renderer.png}}
  \caption{Collection of issues rendered by the domain specific Kanban renderer.}
  \label{fig:issueshydra}
\end{figure}

\paragraph{Intuitive status change}
The Kanban renderer consumes the supported operations per issue and let's the project manager invoke them by in an intuitive way. The look and feel of an issue implies that it can be dropped on the target status. The visual grouping by status helps the project manager to quickly see what the development team is working on.

\paragraph{Optimistic rendering}
Optimistic rendering tries to hide the latency in the client server communication. Instead of awaiting the positive response of the server that confirms that the operation succeeded the client behaves as if the positive response was immediate. This approach only works for operations that are expected to succeed most of the time.

For idempotent HTTP methods like \lstinline{PUT} or \lstinline{DELETE} it is possible to generically implement optimistic rendering. When the project manager for instance removes an issue, the object of the operation is known. The client immediately removes the issue from the UI without waiting for confirmation. When implementing optimistic rendering one has to make sure to handle operation failures in a sensible way. \\
We consider the erroneous case where the project manager removes an issue and it reappears after a few hundred milliseconds. In the worst case he doesn't pay attention after clicking the delete button and goes on thinking that the issue has been removed. This is the reason one has to carefully design optimistic rendering, especially the negative scenario. Often it is not possible or feasible to implement optimistic rendering in a generic way.

The Kanban renderer can leverage domain knowledge to implement optimistic rendering for that specific use case. The Kanban renderer simply appends the issue item to the list of issues in a column. It has the knowledge of vertically aligning issue items that the Hydra renderer lacks. Impossible in going state transitions are communicated by not allowing the issue to be dropped on the \textbf{Backlog} column. Impossible out going state transitions are communicated by not allowing the project manager to pick up an issue that is \textbf{Done}.

\subsubsection{Verification of user stories}
In this section we verify that the user stories listed in table \ref{tab:usecase2} are fulfilled by either accepting or rejecting them.

\begin{table}
  \begin{center}
    \begin{tabular}{ |c|l| }
      \hline
      ID & Accepted/Rejected \\
      \hline
      S01 & Accepted: The project manager can overview all projects \\
      S02 & Accepted: The project manager can overview all issues of a project \\
      S03 & Accepted: The project manager can see the status of an issue \\
      S04 & Accepted: The project manager can see the status of an issue \\
      S05 & Accepted: The project manager can remove issues \\
      S06 & Accepted: The project manager can drag and drop issues \\
      S07 & Accepted: The Hydra renderer shows all data \\
      S08 & Accepted: The UI developer can override the generic renderers \\
      S09 & Accepted: The Hydra renderer exposes all operations by default \\
      \hline
    \end{tabular}
    \caption{All user stories are fulfilled and the second use case is implemented.}
  \end{center}
\end{table}

\subsection{Result}
By implementing a simple dashboard for home automation and a simple Kanban board for project management we have developed the proof of concept of the UI framework. It provides generic rendering capabilities out of the box using the JSON-LD and Hydra renderers. Those can be overridden by custom React components provided by the UI developer. Custom renderers define which \listinline{@type}s they can render, the infrastructure in the client triggers the rendering.

\begin{figure}[!htb]
  \center{\includegraphics[width=380pt]
    {images/ui-dev.png}}
  \caption{Solely the server contains business logic.}
  \label{fig:businesslogic}
\end{figure}

Neither the client nor the custom renderers contain business rules whatsoever. The custom renderers might contain knowledge on how to present business types, but the client is merely a console to the Hydra API as shown in figure \ref{fig:businesslogic}.

\begin{figure}[!htb]
  \center{\includegraphics[width=380pt]
    {images/client-instances.png}}
  \caption{The client is decoupled from any API and is able to consume different APIs.}
  \label{fig:losecoupling}
\end{figure}

This lose coupling between client and API implementation allows the client to be used for various APIs as shown in figure \ref{fig:losecoupling}.

\begin{figure}[!htb]
  \center{\includegraphics[width=380pt]
    {images/ui-dev-custom-renderer.png}}
  \caption{Custom renderers provide the ability to render linked data types. By avoiding hard coding business logic into the client the coupling to the server is still lose.}
  \label{fig:linkeddata}
\end{figure}

By using \textbf{linked data} the use of custom renderers doesn't hurt the re-usability of the client. Linked data always provides a context so it can be understood by machines. That context is not hard coded in the client unlike how it is done in contemporary UI development - especially with SPAs. \\
To elaborate we look at figure \ref{fig:linkeddata} and assume that a custom renderer for the type \lstinline{https://schema.org/Apartment} is implemented. If the responses of API A, API B and API C contain data with \lstinline{@type} \lstinline{https://schema.org/Apartment} the client can consume that data. \\
Often it is required to display data differently depending on the context. The apartment might be rendered differently in a back office application used by administrators and the end-user facing website that lists apartments nearby. The underlying data is the same, the rendered apartment is different. This has to be resolved on the data modeling level by using Hydra classes. Classes can be used to apply additional \lstinline{@type}s depending on the context of the UI.
