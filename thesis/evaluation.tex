\section{Evaluation}
Following paragraph evaluates the proof-of-concept of the UI framework. First, we verify if the design goals were met. Then we list the causes of Accidental Complexity and analyze for each of them if it can be reduced by using the UI framework or not.

\subsection{Design goals}\label{sec:designgoals}
By looking at the implementations of both use cases we evaluate whether the design goals defined in \ref{sec:designgoals} have been met.

\subsubsection{Play nicely with others}
Playing nicely with other technologies, existing consumers and existing tooling is the major design goal as described in section \ref{sec:playnice}. Choices on the technologies being used in the UI framework have the biggest impact on it.

\paragraph{JSON-LD}
JSON-LD is a sub set of JSON which means that any tool that accepts JSON also accepts JSON-LD.

\paragraph{Hydra operations}
Hydra operations include a HTTP verb which the client reads to invoke the operation. Given the developer respects the conventions about safe and idempotent HTTP verbs, their invocations are equal to regular HTTP requests. HTTP proxies and caches treat Hydra requests the same as other HTTP requests.

\paragraph{React}
As discussed in section \ref{sec:react}, React is one of the widely used tools for UI development. The proof of concept of the UI framework accepts only custom renderers using React components. Idiomatic React development uses JSX (JavaScript XML) which requires dedicated support in the development environment. \\
Web components are not fully specified yet but they are on the way to become official standard (TODO cite). Once they are specified and their ecosystem has matured web components might become the better choice to play nicely with others.

\paragraph{Summary}
Due to choice of technology this design goal has been fulfilled and we assess it with a \textbf{score of 3/3}.

\subsubsection{Straightforward upgrade path}
We explore a scenario with a running RESTful HTTP API returning JSON and a client consuming it. The client render the UI with a custom rendering solution that creates the DOM based on input data. They are generating HTTP API documentation with a custom tool and the documentation is served using another server. The development team evaluates the upgrade path to a Hydra conform API and the client using the UI framework. We discuss the upgrade steps to evaluate if the upgrade path is straightforward.

\paragraph{Entity serialization}
The serialization of entities to resources that can be fetched by the client through HTTP remains the same. By adding a header that transmits the context, similar to the \lstinline{@context} property, suffices. The response payload remains the same and existing consumers don't break.

\paragraph{Hydra documentation}
The documentation is served using the meta data mechanism of Hydra. This is again just a response header that points to the documentation of the response resource. The existing API documentation is marked as deprecated. Developers use the Hydra documentation instead of the old one, so that the previous solution can be removed after a grace period.

\paragraph{Hydra operations}
As the current API follows RESTful principles the concept of resources and HTTP methods exists. Resources and HTTP methods are directly mapped to Hydra resources and inline operations of the same HTTP method. This change requires careful design as it might be a breaking change otherwise. Migrating existing HTTP methods to Hydra in a non-breaking way might lead to a non-idiomatic use of Hydra operations. This approach could serve as stepping stone towards using all of Hydra operations power.

\paragraph{Summary}
Due to choice of hypermedia specification and linked data format it is almost straightforward to upgrade existing RESTful APIs returning JSON. The \textbf{score is 2.5/3}.

\subsubsection{Customizability}
In order to assess the customizability of the UI framework we compare the set of UIs that can be implemented using the UI framework with the set of UIs that can be implemented using tools like React.

\paragraph{Plugin mechanism}
The plugin mechanism allows the UI developer to map components to data types. It is possible to register a renderer using the wildcard \lstinline{*} type. This activates the renderer on every type. The UI developer can take control over the rendering by using that to render a React component with all the response data as input. The set of UIs that can be implemented using the UI framework is equal to the set of UIs that can be implemented using React.

\paragraph{Summary}
This design goal is fulfilled which leads to a \textbf{score of 3/3}.

\subsubsection{Developer ergonomics}
We analyze the usage of the UI framework by a developer.

\paragraph{Component API}
Every React component that is invoked by the rendering infrastructure gets the Hydra resource data and a \lstinline{renderer} JavaScript function as input.

\lstset{language=JSON}
\begin{lstlisting}[caption={React component API for the apartment renderer as shown in figure \ref{fig:apartmentrenderer}.}\label{lst:componentapi}]
  const Apartment = ({resource, renderer}) => {
    const { "https://schema.org/containsPlace": rooms } = resource;
    return (
      <div style={{ position: "relative" }}>
        ...
        {rooms.map((r: any) => {
          return (
            <PositionedRoom
              renderer={renderer}
              data={r}
              key={r["@id"]}
              xPos={xPos}
              yPos={yPos}
            />
            );
        })}
      </div>
    )
  }
\end{lstlisting}

Figure \ref{lst:componentapi} shows the apartment renderer of the home automation use case. The \lstinline{resource} contains the data of the Hydra resource of \lstinline{@type} \lstinline{https://schema.org/Apartment}. It accesses the property \lstinline{https://schema.org/containsPlace} to fetch the rooms of the apartment. The \lstinline{renderer} function can be invoked with either a Hydra resource or any JSON. This returns the control of the rendering to the rendering infrastructure.

This allows the UI developer to think in terms of data types and self-contained components. Developing isolated components without thinking about mapping data to children components reduces cognitive load.

\paragraph{Learning curve}
The learning curve of the UI framework is the sum of the learning curves of JSON-LD, React and depending on the use case Hydra. The knowledge required to create and register custom renderers is trivial and can be neglected in this discussion. \\
Superficial knowledge about JSON-LD is sufficient to use the UI framework. If the developer is only concerned with rendering a non-interactive UI knowledge about special JSON-LD properties like \lstinline{@type} and \lstinline{@id} is enough. \\
Although Alcaeus hides implementation details of Hydra, the UI developer should know about operations, classes, documentation and collections in order to create interactive UIs. Deep understanding of Hydra and the Hydra client Alcaeus are required for debugging. \\
The learning curve of using React with the UI framework is flat compared to using React standalone. The developer doesn't have to care about topics like state management and client side routing. React has a mature ecosystem covering these things that comes with a certain cognitive overhead. Using the UI framework the UI developer can focus on learning React without the usual tooling.

\paragraph{Summary}
The learning curve is minimal to implement non-interactive UIs. The component API and renderer registering are simple - the developer can focus on non-infrastructure topics. Implementation of interactive UIs requires good understanding of Hydra. We assess the score of developer ergonomics \textbf{to be 2/3}.

\subsubsection{Summary}
We rate the design goal \textbf{play nicely with other} with 3, \textbf{straightforward upgrade path} with 2.5, \textbf{customizability} with 3 and \textbf{developer ergonomics} with 3 out of possible 3 scores. \\ The design goals have been completely met with the exception of a straightforward upgrade path. The migration of RESTful HTTP methods to Hydra operations is not straightforward.

\subsection{Reduction of complexity in software development}
This section analyzes whether how development using the UI framework affects various types of software complexity. This requires a comparison of a traditional non-linked data driven approach to the development workflow using the UI framework. For that we inspect a development team working on a RESTful HTTP API that returns JSON and on a contemporary frontend as Single Page Application using React. They use Swagger to generate and serve API documentation. We compare that with an alternative scenario where the developers use the UI framework instead of plain React and they work on a HTTP API that conforms to Hydra. For both scenarios we assess various types of software complexities in order to gauge the change. We assume that a change in software complexity is a similar change in software development cost.

Brooks gives \textbf{Complexity}, \textbf{Conformity}, \textbf{Changeability} and \textbf{Invisibility} as the four properties of software causing Essential Complexity \citep{nosilverbullet}.

Out of Tar Pit identifies \textbf{Complexity of State} and \textbf{Complexity of Control} as concrete types of Accidental Complexity.

\subsubsection{Properties of software}

\paragraph{Invisibility}
Software is invisible and unvisualizable. Geometric abstractions are powerful tools. The floor plan of a building helps both architect and client evaluate spaces, traffic flows, views. Contradictions and omissions become obvious. Scale drawings of mechanical parts and stick-figure models of molecules, although abstractions, serve the same purpose. A geometric reality is captured in a geometric abstraction.

The reality of software is not inherently embedded in space. Hence, it has no ready geometric representation in the way that land has maps, silicon chips have diagrams, computers have connectivity schematics. As soon as we attempt to diagram software structure, we find it to constitute not one, but several, general directed graphs superimposed one upon another. The several graphs may represent the flow of control, the flow of data, patterns of dependency, time sequence, name-space relationships. These graphs are usually not even planar, much less hierarchical. Indeed, one of the ways of establishing conceptual control over such structure is to enforce link cutting until one or more of the graphs becomes hierarchical. \citep{nosilverbullet}

The development team starting out with the Hydra API and the UI framework is able to render a fully functional UI without spending any development effort. JSON-LD is rendered as tree and relationships between resources are apparent. The Hydra renderer displays collections of data as tables. In the baseline scenario the developers have to spend a considerable amount of effort on infrastructure before they can render tables. The UI framework \textbf{increases visibility} by providing these visualizations out of the box.

We asses the improvement of complexity caused by Invisibility with a \textbf{score of 3/5}.

\paragraph{Conformity}
Software people are not alone in facing complexity. Physics deals with terribly complex objects even at the "fundamental" particle level. The physicist labors on, however, in a firm faith that there are unifying principles to be found, whether in quarks or in unifiedfield theories. Einstein argued that there must be simplified explanations of nature, because God is not capricious or arbitrary.

No such faith comforts the software engineer. Much of the complexity that he must master is arbitrary complexity, forced without rhyme or reason by the many human institutions and systems to which his interfaces must conform. These differ from interface to interface, and from time to time, not because of necessity but only because they were designed by different people, rather than by God.

In many cases, the software must conform because it is the most recent arrival on the scene. In others, it must conform because it is perceived as the most conformable. But in all cases, much complexity comes from conformation to other interfaces; this complexity cannot be simplified out by any redesign of the software alone. \citep{nosilverbullet}

\paragraph{Changeability}
The software entity is constantly subject to pressures for change. Of course, so are buildings, cars, computers. But manufactured things are infrequently changed after manufacture; they are superseded by later models, or essential changes are incorporated into later-serial-number copies of the same basic design. Call-backs of automobiles are really quite infrequent; field changes of computers somewhat less so. Both are much less frequent than modifications to fielded software.

In part, this is so because the software of a system embodies its function, and the function is the part that most feels the pressures of change. In part it is because software can be changed more easily - it is pure thought-stuff, infinitely malleable. Buildings do in fact get changed, but the high costs of change, understood by all, serve to dampen the whims of the changers. \citep{nosilverbullet}

\paragraph{Complexity}
The complexity of software is an essential property, not an accidental one. Hence, descriptions of a software entity that abstract away its complexity often abstract away its essence. For three centuries, mathematics and the physical sciences made great strides by constructing simplified models of complex phenomena, deriving properties from the models, and verifying those properties by experiment. This paradigm worked because the complexities ignored in the models were not the essential properties of the phenomena. It does not work when the complexities are the essence. \citep{nosilverbullet} \\

\paragraph{Summary}
While it is not possible to get rid of these properties, the UI framework reduces their impact on complexity in the development process.


\subsubsection{Types of Accidental Complexity}
\paragraph{Complexity of state}
TODO out of tarpit
\paragraph{Complexity of control}
TODO out of tarpit
\paragraph{Summary}
